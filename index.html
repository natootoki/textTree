<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ツリー構造エディタ</title>
    <style>
        body {
            font-family: monospace;
            display: flex;
            height: 100vh;
            margin: 0;
        }
        .container {
            display: flex;
            width: 100%;
            overflow: hidden;
        }
        .input-container, .output-container {
            padding: 10px;
            flex: 1;
            width: 50%;
            display: flex;
            flex-direction: column;
        }
        .output-container {
            background: #f4f4f4;
            white-space: pre;
        }
        .input-container textarea {
            width: 100%;
            flex-grow: 1;
            resize: none;
            white-space: pre;
            overflow: auto;
            min-height: 50px;
        }
        .output-container pre {
            white-space: pre;
            overflow: auto;
            flex-grow: 1;
            min-height: 50px;
        }
    </style>
</head>
<body>
    <h2>ツリー構造エディタ</h2>
    <button onclick="makeTree()">Click me</button>
    <div class="container">
        <div class="input-container">
            <h3>入力</h3>
            <textarea id="input" placeholder="ここにツリー構造を入力"></textarea>
        </div>
        <div class="output-container">
            <h3>出力</h3>
            <pre id="output"></pre>
        </div>
    </div>
    
    <script>

        // arrリストのstartIndex番目の要素から、threshold以下の値が登場するまで探索し、
        // 最後にthreshold+1が登場したインデックス番号を返す
        function getLastIndexBeforeThreshold(arr, startIndex, threshold) {
            let lastIndex = startIndex; // 初期値（見つからない場合）

            for (let i = startIndex + 1; i < arr.length; i++) {
                if (arr[i] <= threshold) {
                    break; // `threshold` 以下の値が登場したらループ終了
                }
                if (arr[i] === threshold + 1) {
                    lastIndex = i; // `threshold + 1` の値が登場したらインデックス更新
                }
            }

            return lastIndex;
        }

        // arrリストのstartElemIndex番目からendElemIndex番目の要素を探索し、
        // 
        function replaceCharInRange(arr, startElemIndex, endElemIndex, charIndex, replacement) {
            return arr.map((str, i) => {
                if (i < startElemIndex + 1 || i > endElemIndex) return str; // 指定範囲外なら変更しない
                if (charIndex < 0 || charIndex >= str.length) return str; // 文字の範囲外なら変更しない
                
                return str.substring(0, charIndex) + replacement + str.substring(charIndex + 1);
            });
        }

        function replaceCharIfMatchInString(str, charIndex, targetChar, replacement) {
            if (charIndex === -1) return str; // charIndex が -1 の場合は変更しない
            if (charIndex < 0 || charIndex >= str.length) return str; // インデックス範囲外なら変更しない
            if (str[charIndex] !== targetChar) return str; // 指定の文字でなければ変更しない

            return str.substring(0, charIndex) + replacement + str.substring(charIndex + 1);
        }

        function makeTree() {
            // 入力された文字
            let text = document.getElementById("input").value;
            // 改行区切り、空行除外
            let lines = text.split('\n').filter(line => line.trim() !== "");
            // 各行の先頭のスペース数（全角+半角）を計算
            const spaceCounts = lines.map(line => {
                const match = line.match(/^[\s　]+/); // 先頭の全角・半角スペースを取得
                return match ? match[0].length : 0; // スペースの長さを返す
            });

            let replase_lines = lines;

            //"┃"
            for (let i = 0; i < lines.length; i++) {
                replase_lines = replaceCharInRange(replase_lines, i, getLastIndexBeforeThreshold(spaceCounts, i, spaceCounts[i]), spaceCounts[i], "┃");
            }

            //"┗"
            for (let i = 0; i < lines.length; i++) {
                if (getLastIndexBeforeThreshold(spaceCounts, i, spaceCounts[i]) - i > 0) {
                    replase_lines = replaceCharInRange(replase_lines, getLastIndexBeforeThreshold(spaceCounts, i, spaceCounts[i]) - 1, getLastIndexBeforeThreshold(spaceCounts, i, spaceCounts[i]), spaceCounts[i], "┗");   
                }
            }

            //"┣"
            for (let i = 0; i < lines.length; i++) {
                replase_lines[i] = replaceCharIfMatchInString(replase_lines[i], spaceCounts[i] - 1, "┃", "┣");
            }

            document.getElementById("output").textContent = replase_lines.join("\n");
        }

        document.getElementById("input").addEventListener("input", function () {
            makeTree();
            
        });
    </script>
</body>
</html>
